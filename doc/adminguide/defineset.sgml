<!--  -->
<sect1 id="definingsets">
<title>Defining &slony1; Replication Sets</title>

<indexterm><primary>defining replication sets</primary></indexterm>

<para>Defining the nodes indicated the shape of the cluster of
database servers; it is now time to determine what data is to be
copied between them.  The groups of data that are copied are defined
as <quote>replication sets.</quote></para>

<para>A replication set consists of the following:</para>
<itemizedlist>

<listitem><para>Keys on tables that are to be replicated that have no
suitable primary key</para></listitem>

<listitem><para>Tables that are to be replicated</para></listitem>

<listitem><para>Sequences that are to be replicated</para></listitem>
</itemizedlist>

<sect2><title>Primary Keys</title>

<indexterm><primary>primary key requirement</primary></indexterm>

<para>&slony1; <emphasis>needs</emphasis> to have a primary key or
candidate thereof on each table that is replicated.  PK values are
used as the primary identifier for each tuple that is modified in the
source system.  Note that they can be composite keys composed of
multiple NOT NULL columns; they don't need to consist of single
fields.  There are three ways that you can get &slony1; to use a
primary key:</para>

<itemizedlist>

<listitem><para> If the table has a formally identified primary key,
<xref linkend="stmtsetaddtable"> can be used without any need to
reference the primary key.  &slony1; can automatically pick up that
there is a primary key, and use it.</para></listitem>

<listitem><para> If the table hasn't got a primary key, but has some
<emphasis>candidate</emphasis> primary key, that is, some index on a
combination of fields that is both UNIQUE and NOT NULL, then you can
specify that key, as shown in the following example. </para>

<programlisting>
SET ADD TABLE (set id = 1, origin = 1, id = 42, 
               full qualified name = 'public.this_table', 
               key = 'this_by_that', 
     comment='this_table has this_by_that as a candidate primary key');
</programlisting>

<para> However, once you have come this far, there is little reason not
to just declare some suitable index to be a primary key, which requires
that the columns involved are NOT NULL, and which will establish a unique
index. Here is an example of this: </para>

<programlisting>
DROP INDEX my_table_name_col1_col2_uniq_idx;
ALTER TABLE my_table_name ADD PRIMARY KEY (col1, col2);
</programlisting>

<para>If your application is not somehow referencing the index by name,
then this should not lose you anything, and it gives you the clear design
benefit that a primary key has been declared for the table. </para>

<para> Notice that while you need to specify the namespace for the
table, you must <emphasis>not</emphasis> specify the namespace for the
key, as it infers the namespace from the table.</para></listitem>

<listitem><para> If the table hasn't even got a candidate primary key,
you might ask &slony1; to provide one using 
<xref linkend="stmttableaddkey">.</para>

<warning><para> <xref linkend="stmttableaddkey"> was always considered
a <quote>kludge</quote>, at best, and as of version 2.0, it is
considered such a misfeature that it is being removed.  </para>
</warning>
</listitem>

</itemizedlist>

<para> It is not terribly important whether you pick a
<quote>true</quote> primary key or a mere <quote>candidate primary
key;</quote> it is, however, strongly recommended that you have one of
those instead of having &slony1; populate the PK column for you. If
you don't have a suitable primary key, that means that the table
hasn't got any mechanism, from your application's standpoint, for
keeping values unique.  &slony1; may, therefore, introduce a new
failure mode for your application, and this also implies that you had
a way to enter confusing data into the database.</para>
</sect2>

<sect2 id="definesets"><title>Grouping tables into sets</title>

<indexterm><primary> grouping tables into replication sets </primary></indexterm>

<para> It will be vital to group tables together into a single set if
those tables are related via foreign key constraints.  If tables that
are thus related are <emphasis>not</emphasis> replicated together,
you'll find yourself in trouble if you switch the <quote>master
provider</quote> from one node to another, and discover that the new
<quote>master</quote> can't be updated properly because it is missing
the contents of dependent tables.</para>

<para> There are also several reasons why you might
<emphasis>not</emphasis> want to have all of the tables in one
replication set:

<itemizedlist>

<listitem><para> The initial <command>COPY_SET</command> event for a
large set leads to a <link linkend="longtxnsareevil"> long running
transaction </link> on the provider node.  The <link linkend="faq">
FAQ </link> outlines a number of problems that result from long
running transactions that will injure system performance.</para>

<para> If you can split such a large set into several smaller pieces,
that will shorten the length of each of the transactions, lessening
the degree of the <quote>injury</quote> to performance.</para>

<para> Another issue comes up particularly frequently when replicating
across a WAN; sometimes the network connection is a little bit
unstable, such that there is a risk that a connection held open for
several hours will lead to <command>CONNECTION TIMEOUT.</command> If
that happens when 95% done copying a 50-table replication set
consisting of 250GB of data, that could ruin your whole day.  If the
tables were, instead, associated with separate replication sets, that
failure at the 95% point might only interrupt, temporarily, the
copying of <emphasis>one</emphasis> of those tables.  </para>

<para> These <quote>negative effects</quote> tend to emerge when the
database being subscribed to is many gigabytes in size and where it
takes many hours or even days for the subscriber to complete the
initial data copy.  For relatively small databases, this shouldn't be
a material factor.
</para>
</listitem>

<listitem><para> Any time you invoke <xref linkend="stmtddlscript">,
this requests a lock on <emphasis> every single table in the
replication set, first, on the origin node, and then, as the event
propagates to other nodes, to each subscriber node. </emphasis></para>

<para> There have been reports <quote>in the field</quote> of this
leading to deadlocks such that the <xref linkend="stmtddlscript">
request had to be submitted many times in order for it to actually
complete successfully.</para>

<para> The more tables you have in a set, the more tables need to be
locked, and the greater the chances of deadlocks. </para>

<para> By the same token, if a particular DDL script only needs to
affect a couple of tables, you might use <xref
linkend="stmtsetmovetable"> to move them temporarily to a new
replication set.  By diminishing the number of locks needed, this
should ease the ability to get the DDL change into place.</para>

<para> There is a further <link linkend="locking"> discussion of
locking </link> which outlines where &slony1; requires locks likely to
intrude on your applications.</para>
</listitem>

</itemizedlist></para>

</sect2>

<sect2> <title> The Pathology of Sequences </title>

<indexterm><primary>sequence pathology</primary></indexterm>

<para> Each time a SYNC is processed, values are recorded for
<emphasis>all</emphasis> of the sequences in the set.  If there are a
lot of sequences, this can cause &slseqlog; to grow rather
large.</para>

<para> This points to an important difference between tables and
sequences: if you add additional tables that do not see much/any
activity, this does not add any material load to the work being done
by replication.  For a replicated sequence, values must
<emphasis>regularly</emphasis> be propagated to subscribers.  Consider
the effects:

<itemizedlist>

<listitem><para> A replicated table that is never updated does not
introduce much work to the system.</para>

<para> If it is not updated, the trigger on the table on the origin
never fires, and no entries are added to &sllog1;/&sllog2;.  The table never appears in any of the
further replication queries (<emphasis>e.g.</emphasis> in the
<command>FETCH 100 FROM LOG</command> queries used to find
replicatable data) as they only look for tables for which there are
entries in &sllog1;/&sllog2;.</para></listitem>

<listitem><para> In contrast, a fixed amount of work is introduced to
each SYNC by each sequence that is replicated.</para>

<para> Replicate 300 sequence and 300 rows need to be added to
&slseqlog; on a regular basis, at least, thru until the 2.0 branch,
where updates are only applied when the value of a given sequence is
seen to change.</para>

<para> It is more than likely that if the value of a particular
sequence hasn't changed since it was last checked, perhaps the same
value need not be stored over and over; some thought needs to go into
how to do that safely.</para></listitem>

<listitem><para> <ulink url=
"http://gborg.postgresql.org/project/slony1/bugs/bugupdate.php?1226">
Bug #1226 </ulink> indicates an error condition that can come up if
you have a replication set that consists solely of sequences. </para>

<para> This is documented more in the <link linkend="sequenceset"> FAQ
here;</link> the long and short is that having a replication set
consisting only of sequences is not a particularly good
idea.</para></listitem>

</itemizedlist></para></sect2>

</sect1>
<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:"slony.sgml"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
